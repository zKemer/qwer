const language = require('./src/language.json');
const methods = require('./src/methods.js');
const fs = require('fs');

class Dark {

    constructor(darkOptions = { file: null, readable: null, language: null }) {
        this.file = darkOptions['file'];
        this.readable = darkOptions['readable'];
        this.language = darkOptions['language'];

        if (!this.language) throw new Error(language.errors['noLang']["MIX"]);
        if (!["EN", "TR"].includes(this.language.toUpperCase())) throw new Error(language.errors['notValidLang']["MIX"]);

        if (!this.file) throw new Error(language.errors['noFile'][this.language.toUpperCase()]);
        if (this.file.slice(-5) !== ".json") throw new Error(language.errors['notValidFile'][this.language.toUpperCase()]);

        if (!this.readable) throw new Error(language.errors['noReadableData'][this.language.toUpperCase()]);
        if (!['true', 'false'].includes(this.readable.toLowerCase())) throw new Error(language.errors['notValidReadableData'][this.language.toUpperCase()]);
        methods.syncFile(this.file);
    };

    set(darkName, darkValue) {
        try {
            methods.syncFile(this.file);    
            if (!darkName) throw new Error(language.errors['set_noData'][this.language.toUpperCase()]);
            if (!darkValue) throw new Error(language.errors['set_noValue'][this.language.toUpperCase()]);
    
            const oldDataBase = JSON.parse(fs.readFileSync(this.file, 'utf8'));
            methods.set(darkName, darkValue, oldDataBase);
    
            fs.writeFileSync(this.file, (this.readable.toLowerCase() == 'true' ? JSON.stringify(oldDataBase, null, 2) : JSON.stringify(oldDataBase)));
            return true;
        } catch(darkError) {
            throw new Error(darkError);
        };
    };

    get(darkName) {
        try {
            if (!darkName) throw new Error(language.errors['get_noData'][this.language.toUpperCase()]);
            const db = JSON.parse(fs.readFileSync(this.file, 'utf8'));
            return methods.get(darkName, db);
        } catch(darkError) {
            throw new Error(darkError);
        };
    };

    fetch(darkName) {
        try {
            if (!darkName) throw new Error(language.errors['get_noData'][this.language.toUpperCase()]);
            return this.get(darkName);
        } catch(darkError) {
            throw new Error(darkError);
        };
    };

    has(darkName) {
        try {
            if (!darkName) throw new Error(language.errors['get_noData'][this.language.toUpperCase()]);
            return this.get(darkName) ? true : null;
        } catch(darkError) {
            throw new Error(darkError);
        };
    };

    delete(darkName) {
        try {
            methods.syncFile(this.file);
            if (!darkName) throw new Error(language.errors['delete_noData'][this.language.toUpperCase()]);
            if (!this.get(darkName)) return false;

            const db = JSON.parse(fs.readFileSync(this.file, 'utf8'));
            methods.delete(darkName, db);

            fs.writeFileSync(this.file, (this.readable.toLowerCase() == 'true' ? JSON.stringify(db, null, 2) : JSON.stringify(db)));
            return true;
        } catch(darkError) {
            throw new Error(darkError);
        };
    };

    add(darkName, darkValue) {
        try {
            if (!darkName) throw new Error(language.errors['add_noData'][this.language.toUpperCase()]);
            if (!darkValue) throw new Error(language.errors['add_noValue'][this.language.toUpperCase()]);

            if (typeof darkValue !== 'number') throw new Error(language.errors['add_falseValue'][this.language.toUpperCase()]);
            if (typeof (this.get(darkName) ? this.get(darkName) : 0) !== 'number') throw new Error(language.errors['add_falseValue2'][this.language.toUpperCase()]);

            var addedValue = (this.get(darkName) ? this.get(darkName) : 0) + darkValue;
            if (addedValue !== 0) {
                this.set(darkName, addedValue);
            } else {
                this.delete(darkName);
            };

            return true;
        } catch(darkError) {
            throw new Error(darkError);
        };
    };

    push(darkName, darkValue) {
        try {
            if (!darkName) throw new Error(language.errors['push_noData'][this.language.toUpperCase()]);
            if (!darkValue) throw new Error(language.errors['push_noValue'][this.language.toUpperCase()]);

            let oldData = [];
            if (typeof this.get(darkName) == "object") oldData = this.get(darkName);

            oldData.push(darkValue);
            this.set(darkName, oldData);
            return true;
        } catch(darkError) {
            throw new Error(darkError);
        };
    };

    pull(darkName, darkValue) {
        try {
            if (!darkName) throw new Error(language.errors['pull_noData'][this.language.toUpperCase()]);
            if (!darkValue) throw new Error(language.errors['pull_noValue'][this.language.toUpperCase()]);

            let newData = this.get(darkName) ? this.get(darkName).filter(data => data !== darkValue) : [];
            this.set(darkName, newData);
            return true;
        } catch(darkError) {
            throw new Error(darkError);
        };
    };

    import(darkDatas) {
        try {
            if (!darkDatas) throw new Error(language.errors['import_noData'][this.language.toUpperCase()]);
            console.log(language.errors['import_started'][this.language.toUpperCase()])
            const allDatas = darkDatas.all().map(db => db);

            for(let i = 0; i < allDatas.length; i++) {
                this.set(allDatas[i].ID, allDatas[i].data);
                console.log('[dark.db] ' + (i + 1) + '/' + allDatas.length);
            };

            console.log(language.errors['import_completed'][this.language.toUpperCase()])
            return true;
        } catch(darkError) {
            throw new Error(darkError);
        };
    };

    backup() {
        try {
            if (fs.existsSync('backup') == false) fs.mkdirSync('backup');
            fs.copyFile(this.file, require('path').resolve('backup', ('backup-' + Date.now() + '.json')), () => {});
            return true;
        } catch(darkError) {
            throw new Error(darkError);
        };
    };

    all() {
        return JSON.parse(fs.readFileSync(this.file, 'utf8'));
    };

    deleteAll() {
        fs.writeFileSync(this.file, '{}');
        return true;
    };
};

module.exports = Dark;